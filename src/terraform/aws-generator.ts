/**
 * AWS Terraform Generator
 * Generates AWS Terraform configurations from scan results
 */

import { ScanResult, CloudResource } from '../types';
import { TerraformOptions, TerraformOutput, sanitizeResourceName, generateResourceTags, generateVariable, generateOutput } from './index';

export async function generateAWSTerraform(
  scanResult: ScanResult,
  options: TerraformOptions
): Promise<TerraformOutput> {

  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];
  const modules: { [key: string]: string } = {};

  // Generate provider configuration
  const providerTf = generateAWSProvider(scanResult.region);

  // Generate resources by type
  if (scanResult.resources.compute.length > 0) {
    const computeConfig = generateEC2Instances(scanResult.resources.compute, options);
    resources.push(computeConfig.resources);
    variables.push(...computeConfig.variables);
    outputs.push(...computeConfig.outputs);
  }

  if (scanResult.resources.storage.length > 0) {
    const storageConfig = generateS3Buckets(scanResult.resources.storage, options);
    resources.push(storageConfig.resources);
    variables.push(...storageConfig.variables);
    outputs.push(...storageConfig.outputs);
  }

  if (scanResult.resources.database.length > 0) {
    const databaseConfig = generateRDSInstances(scanResult.resources.database, options);
    resources.push(databaseConfig.resources);
    variables.push(...databaseConfig.variables);
    outputs.push(...databaseConfig.outputs);
  }

  if (scanResult.resources.network.length > 0) {
    const networkConfig = generateNetworkResources(scanResult.resources.network, options);
    resources.push(networkConfig.resources);
    variables.push(...networkConfig.variables);
    outputs.push(...networkConfig.outputs);
  }

  if (scanResult.resources.serverless.length > 0) {
    const serverlessConfig = generateLambdaFunctions(scanResult.resources.serverless, options);
    resources.push(serverlessConfig.resources);
    variables.push(...serverlessConfig.variables);
    outputs.push(...serverlessConfig.outputs);
  }

  // Generate main configuration
  const mainTf = generateMainConfiguration(resources, scanResult);

  // Generate variables file if requested
  const variablesTf = options.variables ? variables.join('\n') : undefined;

  // Generate outputs file if requested
  const outputsTf = options.outputs ? outputs.join('\n') : undefined;

  // Generate terraform.tfvars file
  const terraformTfvars = generateTerraformTfvars(scanResult);

  return {
    mainTf,
    providerTf,
    variablesTf,
    outputsTf,
    terraformTfvars,
    modules: options.modules ? modules : undefined
  };
}

function generateAWSProvider(region: string): string {
  return `# AWS Provider Configuration
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region

  # Optional: Configure default tags for all resources
  default_tags {
    tags = {
      Project     = var.project_name
      Environment = var.environment
      ManagedBy   = "terraform"
      GeneratedBy = "optimisely-cloud-sdk"
    }
  }
}
`;
}

function generateMainConfiguration(resources: string[], scanResult: ScanResult): string {
  const header = `# Infrastructure Configuration Generated by Optimisely Cloud SDK
# Original scan performed on: ${scanResult.timestamp}
# Provider: ${scanResult.provider.toUpperCase()}
# Region: ${scanResult.region}
# Total Resources: ${scanResult.totalResources}

`;

  return header + resources.join('\n\n');
}

function generateEC2Instances(instances: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Add common variables
  variables.push(generateVariable('instance_type_override', 'Override instance type for all instances', 'string'));
  variables.push(generateVariable('key_name', 'EC2 Key Pair name for SSH access', 'string'));

  instances.forEach((instance, index) => {
    const resourceName = sanitizeResourceName(instance.name || `instance_${index}`);
    const tags = generateResourceTags(instance);

    // Extract instance configuration
    const instanceType = instance.instanceType || 't3.micro';
    const availabilityZone = instance.availabilityZone || 'var.aws_region';
    const subnetId = instance.subnetId || 'aws.subnet.default.id';

    const resource = `# EC2 Instance: ${instance.name}
resource "aws_instance" "${resourceName}" {
  ami           = data.aws_ami.${resourceName}.id
  instance_type = var.instance_type_override != "" ? var.instance_type_override : "${instanceType}"
  key_name      = var.key_name

  subnet_id                   = ${subnetId}
  vpc_security_group_ids      = [aws_security_group.${resourceName}.id]
  associate_public_ip_address = ${instance.publicIp ? 'true' : 'false'}

  root_block_device {
    volume_type = "gp3"
    volume_size = ${instance.storage?.size || 20}
    encrypted   = true
  }${tags}

  lifecycle {
    create_before_destroy = true
  }
}

# Data source for latest AMI
data "aws_ami" "${resourceName}" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

# Security Group for ${instance.name}
resource "aws_security_group" "${resourceName}" {
  name_prefix = "${resourceName}-"
  description = "Security group for ${instance.name}"

  # Allow SSH access
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = [var.allowed_ssh_cidr]
  }

  # Allow HTTP access
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # Allow HTTPS access
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # Allow all outbound traffic
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }${tags}
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `aws_instance.${resourceName}.id`,
      `ID of the ${instance.name} EC2 instance`
    ));

    outputs.push(generateOutput(
      `${resourceName}_public_ip`,
      `aws_instance.${resourceName}.public_ip`,
      `Public IP address of the ${instance.name} EC2 instance`
    ));

    outputs.push(generateOutput(
      `${resourceName}_private_ip`,
      `aws_instance.${resourceName}.private_ip`,
      `Private IP address of the ${instance.name} EC2 instance`
    ));
  });

  // Add common variables
  variables.push(generateVariable('allowed_ssh_cidr', 'CIDR block allowed for SSH access', 'string', '10.0.0.0/8'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateS3Buckets(buckets: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  buckets.forEach((bucket, index) => {
    const resourceName = sanitizeResourceName(bucket.name || `bucket_${index}`);
    const tags = generateResourceTags(bucket);

    const resource = `# S3 Bucket: ${bucket.name}
resource "aws_s3_bucket" "${resourceName}" {
  bucket = "\${var.bucket_prefix}-${bucket.name}-\${random_string.${resourceName}.result}"${tags}
}

resource "random_string" "${resourceName}" {
  length  = 8
  special = false
  upper   = false
}

# S3 Bucket versioning
resource "aws_s3_bucket_versioning" "${resourceName}" {
  bucket = aws_s3_bucket.${resourceName}.id
  versioning_configuration {
    status = var.enable_versioning ? "Enabled" : "Suspended"
  }
}

# S3 Bucket encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "${resourceName}" {
  bucket = aws_s3_bucket.${resourceName}.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# S3 Bucket public access block
resource "aws_s3_bucket_public_access_block" "${resourceName}" {
  bucket = aws_s3_bucket.${resourceName}.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `aws_s3_bucket.${resourceName}.id`,
      `ID of the ${bucket.name} S3 bucket`
    ));

    outputs.push(generateOutput(
      `${resourceName}_arn`,
      `aws_s3_bucket.${resourceName}.arn`,
      `ARN of the ${bucket.name} S3 bucket`
    ));
  });

  // Add variables
  variables.push(generateVariable('bucket_prefix', 'Prefix for S3 bucket names', 'string', 'optimisely'));
  variables.push(generateVariable('enable_versioning', 'Enable S3 bucket versioning', 'bool', true));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateRDSInstances(databases: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  databases.forEach((database, index) => {
    const resourceName = sanitizeResourceName(database.name || `database_${index}`);
    const tags = generateResourceTags(database);

    const engine = database.engine || 'mysql';
    const instanceClass = database.instanceType || 'db.t3.micro';
    const allocatedStorage = database.storage?.size || 20;

    const resource = `# RDS Instance: ${database.name}
resource "aws_db_instance" "${resourceName}" {
  identifier = "\${var.db_prefix}-${resourceName}"

  # Database Configuration
  engine                = "${engine}"
  engine_version        = var.${engine}_version
  instance_class        = "${instanceClass}"
  allocated_storage     = ${allocatedStorage}
  max_allocated_storage = ${allocatedStorage * 2}
  storage_type          = "gp3"
  storage_encrypted     = true

  # Database Credentials
  db_name  = var.${resourceName}_db_name
  username = var.${resourceName}_username
  password = var.${resourceName}_password

  # Network Configuration
  db_subnet_group_name   = aws_db_subnet_group.${resourceName}.name
  vpc_security_group_ids = [aws_security_group.${resourceName}_db.id]

  # Backup Configuration
  backup_retention_period = var.backup_retention_days
  backup_window          = var.backup_window
  maintenance_window     = var.maintenance_window

  # Security Configuration
  deletion_protection = var.deletion_protection
  skip_final_snapshot = !var.final_snapshot_enabled${tags}

  lifecycle {
    prevent_destroy = true
  }
}

# DB Subnet Group
resource "aws_db_subnet_group" "${resourceName}" {
  name       = "\${var.db_prefix}-${resourceName}-subnet-group"
  subnet_ids = var.database_subnet_ids${tags}
}

# Security Group for Database
resource "aws_security_group" "${resourceName}_db" {
  name_prefix = "${resourceName}-db-"
  description = "Security group for ${database.name} database"

  ingress {
    from_port       = ${getDatabasePort(engine)}
    to_port         = ${getDatabasePort(engine)}
    protocol        = "tcp"
    security_groups = [aws_security_group.${resourceName}_app.id]
  }${tags}
}

# Security Group for Application Access
resource "aws_security_group" "${resourceName}_app" {
  name_prefix = "${resourceName}-app-"
  description = "Security group for applications accessing ${database.name}"${tags}
}`;

    resources.push(resource);

    // Add database-specific variables
    variables.push(generateVariable(`${resourceName}_db_name`, `Database name for ${database.name}`, 'string', resourceName));
    variables.push(generateVariable(`${resourceName}_username`, `Database username for ${database.name}`, 'string', 'admin'));
    variables.push(generateVariable(`${resourceName}_password`, `Database password for ${database.name}`, 'string'));

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_endpoint`,
      `aws_db_instance.${resourceName}.endpoint`,
      `Database endpoint for ${database.name}`,
      false
    ));

    outputs.push(generateOutput(
      `${resourceName}_port`,
      `aws_db_instance.${resourceName}.port`,
      `Database port for ${database.name}`,
      false
    ));
  });

  // Add common variables
  variables.push(generateVariable('db_prefix', 'Prefix for database identifiers', 'string', 'optimisely'));
  variables.push(generateVariable('mysql_version', 'MySQL engine version', 'string', '8.0'));
  variables.push(generateVariable('postgres_version', 'PostgreSQL engine version', 'string', '15.4'));
  variables.push(generateVariable('backup_retention_days', 'Number of days to retain backups', 'number', 7));
  variables.push(generateVariable('backup_window', 'Daily backup window', 'string', '03:00-04:00'));
  variables.push(generateVariable('maintenance_window', 'Weekly maintenance window', 'string', 'sun:04:00-sun:05:00'));
  variables.push(generateVariable('deletion_protection', 'Enable deletion protection', 'bool', true));
  variables.push(generateVariable('final_snapshot_enabled', 'Enable final snapshot on deletion', 'bool', true));
  variables.push(generateVariable('database_subnet_ids', 'List of subnet IDs for database', 'list(string)'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateNetworkResources(networks: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Generate VPC resources
  const vpcs = networks.filter(n => n.resourceType === 'VPC' || n.name?.toLowerCase().includes('vpc'));
  const subnets = networks.filter(n => n.resourceType === 'Subnet' || n.name?.toLowerCase().includes('subnet'));
  const securityGroups = networks.filter(n => n.resourceType === 'SecurityGroup' || n.name?.toLowerCase().includes('security'));

  vpcs.forEach((vpc, index) => {
    const resourceName = sanitizeResourceName(vpc.name || `vpc_${index}`);
    const tags = generateResourceTags(vpc);

    const resource = `# VPC: ${vpc.name}
resource "aws_vpc" "${resourceName}" {
  cidr_block           = var.${resourceName}_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true${tags}
}

# Internet Gateway
resource "aws_internet_gateway" "${resourceName}_igw" {
  vpc_id = aws_vpc.${resourceName}.id${tags}
}

# Route Table
resource "aws_route_table" "${resourceName}_public" {
  vpc_id = aws_vpc.${resourceName}.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.${resourceName}_igw.id
  }${tags}
}`;

    resources.push(resource);

    variables.push(generateVariable(`${resourceName}_cidr`, `CIDR block for ${vpc.name} VPC`, 'string', '10.0.0.0/16'));

    outputs.push(generateOutput(
      `${resourceName}_id`,
      `aws_vpc.${resourceName}.id`,
      `ID of the ${vpc.name} VPC`
    ));
  });

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateLambdaFunctions(functions: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  functions.forEach((func, index) => {
    const resourceName = sanitizeResourceName(func.name || `function_${index}`);
    const tags = generateResourceTags(func);

    const resource = `# Lambda Function: ${func.name}
resource "aws_lambda_function" "${resourceName}" {
  filename         = "\${path.module}/lambda_functions/${resourceName}.zip"
  function_name    = "\${var.function_prefix}-${resourceName}"
  role            = aws_iam_role.${resourceName}_lambda.arn
  handler         = var.${resourceName}_handler
  runtime         = var.${resourceName}_runtime
  timeout         = var.${resourceName}_timeout
  memory_size     = var.${resourceName}_memory

  source_code_hash = filebase64sha256("\${path.module}/lambda_functions/${resourceName}.zip")${tags}
}

# IAM Role for Lambda Function
resource "aws_iam_role" "${resourceName}_lambda" {
  name = "\${var.function_prefix}-${resourceName}-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Basic execution policy for Lambda
resource "aws_iam_role_policy_attachment" "${resourceName}_lambda_basic" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.${resourceName}_lambda.name
}`;

    resources.push(resource);

    // Add function-specific variables
    variables.push(generateVariable(`${resourceName}_handler`, `Handler for ${func.name} function`, 'string', 'index.handler'));
    variables.push(generateVariable(`${resourceName}_runtime`, `Runtime for ${func.name} function`, 'string', 'nodejs18.x'));
    variables.push(generateVariable(`${resourceName}_timeout`, `Timeout for ${func.name} function`, 'number', 30));
    variables.push(generateVariable(`${resourceName}_memory`, `Memory for ${func.name} function`, 'number', 128));

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_arn`,
      `aws_lambda_function.${resourceName}.arn`,
      `ARN of the ${func.name} Lambda function`
    ));

    outputs.push(generateOutput(
      `${resourceName}_name`,
      `aws_lambda_function.${resourceName}.function_name`,
      `Name of the ${func.name} Lambda function`
    ));
  });

  // Add common variables
  variables.push(generateVariable('function_prefix', 'Prefix for Lambda function names', 'string', 'optimisely'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateTerraformTfvars(scanResult: ScanResult): string {
  return `# Terraform Variables for ${scanResult.provider.toUpperCase()} Infrastructure
# Generated by Optimisely Cloud SDK

# General Configuration
aws_region      = "${scanResult.region}"
project_name    = "optimisely-recreated"
environment     = "production"

# EC2 Configuration
instance_type_override = ""
key_name              = ""  # Set your EC2 key pair name
allowed_ssh_cidr      = "10.0.0.0/8"

# S3 Configuration
bucket_prefix     = "optimisely"
enable_versioning = true

# RDS Configuration
db_prefix             = "optimisely"
backup_retention_days = 7
deletion_protection   = true
final_snapshot_enabled = true

# Network Configuration
database_subnet_ids = []  # List of subnet IDs for databases

# Lambda Configuration
function_prefix = "optimisely"
`;
}

function getDatabasePort(engine: string): number {
  const ports: { [key: string]: number } = {
    mysql: 3306,
    postgres: 5432,
    mariadb: 3306,
    oracle: 1521,
    sqlserver: 1433
  };

  return ports[engine.toLowerCase()] || 3306;
}