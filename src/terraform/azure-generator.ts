/**
 * Azure Terraform Generator
 * Generates Azure Terraform configurations from scan results
 */

import { ScanResult, CloudResource } from '../types';
import { TerraformOptions, TerraformOutput, sanitizeResourceName, generateResourceTags, generateVariable, generateOutput } from './index';

export async function generateAzureTerraform(
  scanResult: ScanResult,
  options: TerraformOptions
): Promise<TerraformOutput> {

  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];
  const modules: { [key: string]: string } = {};

  // Generate provider configuration
  const providerTf = generateAzureProvider();

  // Generate Resource Group first (required for all Azure resources)
  const resourceGroupConfig = generateResourceGroup(scanResult);
  resources.push(resourceGroupConfig.resources);
  variables.push(...resourceGroupConfig.variables);
  outputs.push(...resourceGroupConfig.outputs);

  // Generate resources by type
  if (scanResult.resources.compute.length > 0) {
    const computeConfig = generateVirtualMachines(scanResult.resources.compute, options);
    resources.push(computeConfig.resources);
    variables.push(...computeConfig.variables);
    outputs.push(...computeConfig.outputs);
  }

  if (scanResult.resources.storage.length > 0) {
    const storageConfig = generateStorageAccounts(scanResult.resources.storage, options);
    resources.push(storageConfig.resources);
    variables.push(...storageConfig.variables);
    outputs.push(...storageConfig.outputs);
  }

  if (scanResult.resources.network.length > 0) {
    const networkConfig = generateNetworkResources(scanResult.resources.network, options);
    resources.push(networkConfig.resources);
    variables.push(...networkConfig.variables);
    outputs.push(...networkConfig.outputs);
  }

  // Generate main configuration
  const mainTf = generateMainConfiguration(resources, scanResult);

  // Generate variables file if requested
  const variablesTf = options.variables ? variables.join('\n') : undefined;

  // Generate outputs file if requested
  const outputsTf = options.outputs ? outputs.join('\n') : undefined;

  // Generate terraform.tfvars file
  const terraformTfvars = generateTerraformTfvars(scanResult);

  return {
    mainTf,
    providerTf,
    variablesTf,
    outputsTf,
    terraformTfvars,
    modules: options.modules ? modules : undefined
  };
}

function generateAzureProvider(): string {
  return `# Azure Provider Configuration
terraform {
  required_version = ">= 1.0"
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {
    resource_group {
      prevent_deletion_if_contains_resources = false
    }

    virtual_machine {
      delete_os_disk_on_deletion     = true
      graceful_shutdown_timeout      = "5m"
      skip_shutdown_and_force_delete = false
    }

    storage_account {
      prevent_data_loss = true
    }
  }

  # Optional: Specify subscription ID
  # subscription_id = var.subscription_id
}
`;
}

function generateMainConfiguration(resources: string[], scanResult: ScanResult): string {
  const header = `# Azure Infrastructure Configuration Generated by Optimisely Cloud SDK
# Original scan performed on: ${scanResult.timestamp}
# Provider: ${scanResult.provider.toUpperCase()}
# Region: ${scanResult.region}
# Total Resources: ${scanResult.totalResources}

`;

  return header + resources.join('\n\n');
}

function generateResourceGroup(scanResult: ScanResult) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  const resource = `# Resource Group
resource "azurerm_resource_group" "main" {
  name     = var.resource_group_name
  location = var.location

  tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "terraform"
    GeneratedBy = "optimisely-cloud-sdk"
  }
}`;

  resources.push(resource);

  // Add variables
  variables.push(generateVariable('resource_group_name', 'Name of the resource group', 'string', 'optimisely-resources'));
  variables.push(generateVariable('location', 'Azure region for resources', 'string', scanResult.region || 'East US'));
  variables.push(generateVariable('project_name', 'Name of the project', 'string', 'optimisely-recreated'));
  variables.push(generateVariable('environment', 'Environment name', 'string', 'production'));

  // Add outputs
  outputs.push(generateOutput(
    'resource_group_name',
    'azurerm_resource_group.main.name',
    'Name of the created resource group'
  ));

  outputs.push(generateOutput(
    'resource_group_id',
    'azurerm_resource_group.main.id',
    'ID of the created resource group'
  ));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateVirtualMachines(instances: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Add common variables
  variables.push(generateVariable('admin_username', 'Admin username for virtual machines', 'string', 'azureuser'));
  variables.push(generateVariable('admin_password', 'Admin password for virtual machines', 'string'));
  variables.push(generateVariable('vm_size_override', 'Override VM size for all instances', 'string', ''));

  instances.forEach((instance, index) => {
    const resourceName = sanitizeResourceName(instance.name || `vm_${index}`);
    const tags = generateAzureResourceTags(instance);

    // Map AWS instance types to Azure VM sizes
    const vmSize = mapAWSInstanceTypeToAzureVMSize(instance.instanceType) || 'Standard_B1s';

    const resource = `# Virtual Machine: ${instance.name}
resource "azurerm_linux_virtual_machine" "${resourceName}" {
  name                = "\${var.vm_prefix}-${resourceName}"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  size                = var.vm_size_override != "" ? var.vm_size_override : "${vmSize}"
  admin_username      = var.admin_username

  # Disable password authentication and use SSH keys
  disable_password_authentication = true

  network_interface_ids = [
    azurerm_network_interface.${resourceName}.id,
  ]

  admin_ssh_key {
    username   = var.admin_username
    public_key = file(var.ssh_public_key_path)
  }

  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Premium_LRS"
  }

  source_image_reference {
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-focal"
    sku       = "20_04-lts-gen2"
    version   = "latest"
  }${tags}
}

# Network Interface for ${instance.name}
resource "azurerm_network_interface" "${resourceName}" {
  name                = "\${var.vm_prefix}-${resourceName}-nic"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.${resourceName}.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.${resourceName}.id
  }${tags}
}

# Public IP for ${instance.name}
resource "azurerm_public_ip" "${resourceName}" {
  name                = "\${var.vm_prefix}-${resourceName}-pip"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  allocation_method   = "Dynamic"${tags}
}

# Subnet for ${instance.name}
resource "azurerm_subnet" "${resourceName}" {
  name                 = "\${var.vm_prefix}-${resourceName}-subnet"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.${resourceName}.name
  address_prefixes     = ["10.0.${index + 1}.0/24"]
}

# Virtual Network for ${instance.name}
resource "azurerm_virtual_network" "${resourceName}" {
  name                = "\${var.vm_prefix}-${resourceName}-vnet"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  address_space       = ["10.0.0.0/16"]${tags}
}

# Network Security Group for ${instance.name}
resource "azurerm_network_security_group" "${resourceName}" {
  name                = "\${var.vm_prefix}-${resourceName}-nsg"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  security_rule {
    name                       = "SSH"
    priority                   = 1001
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "22"
    source_address_prefix      = var.allowed_ssh_cidr
    destination_address_prefix = "*"
  }

  security_rule {
    name                       = "HTTP"
    priority                   = 1002
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "80"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }

  security_rule {
    name                       = "HTTPS"
    priority                   = 1003
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "443"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }${tags}
}

# Associate Network Security Group to Subnet
resource "azurerm_subnet_network_security_group_association" "${resourceName}" {
  subnet_id                 = azurerm_subnet.${resourceName}.id
  network_security_group_id = azurerm_network_security_group.${resourceName}.id
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `azurerm_linux_virtual_machine.${resourceName}.id`,
      `ID of the ${instance.name} virtual machine`
    ));

    outputs.push(generateOutput(
      `${resourceName}_public_ip`,
      `azurerm_public_ip.${resourceName}.ip_address`,
      `Public IP address of the ${instance.name} virtual machine`
    ));

    outputs.push(generateOutput(
      `${resourceName}_private_ip`,
      `azurerm_network_interface.${resourceName}.private_ip_address`,
      `Private IP address of the ${instance.name} virtual machine`
    ));
  });

  // Add common variables
  variables.push(generateVariable('vm_prefix', 'Prefix for VM names', 'string', 'optimisely'));
  variables.push(generateVariable('ssh_public_key_path', 'Path to SSH public key file', 'string', '~/.ssh/id_rsa.pub'));
  variables.push(generateVariable('allowed_ssh_cidr', 'CIDR block allowed for SSH access', 'string', '0.0.0.0/0'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateStorageAccounts(storageResources: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  storageResources.forEach((storage, index) => {
    const resourceName = sanitizeResourceName(storage.name || `storage_${index}`);
    const tags = generateAzureResourceTags(storage);

    const resource = `# Storage Account: ${storage.name}
resource "azurerm_storage_account" "${resourceName}" {
  name                     = "\${var.storage_prefix}${resourceName}\${random_string.${resourceName}.result}"
  resource_group_name      = azurerm_resource_group.main.name
  location                 = azurerm_resource_group.main.location
  account_tier             = "Standard"
  account_replication_type = var.storage_replication_type

  # Security settings
  allow_nested_items_to_be_public = false
  shared_access_key_enabled       = true
  https_traffic_only_enabled      = true
  min_tls_version                 = "TLS1_2"

  # Network rules
  network_rules {
    default_action             = "Deny"
    ip_rules                   = var.allowed_ips
    virtual_network_subnet_ids = []
    bypass                     = ["AzureServices"]
  }${tags}
}

resource "random_string" "${resourceName}" {
  length  = 8
  special = false
  upper   = false
}

# Storage Container
resource "azurerm_storage_container" "${resourceName}_container" {
  name                  = "data"
  storage_account_name  = azurerm_storage_account.${resourceName}.name
  container_access_type = "private"
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `azurerm_storage_account.${resourceName}.id`,
      `ID of the ${storage.name} storage account`
    ));

    outputs.push(generateOutput(
      `${resourceName}_primary_endpoint`,
      `azurerm_storage_account.${resourceName}.primary_blob_endpoint`,
      `Primary blob endpoint of the ${storage.name} storage account`
    ));

    outputs.push(generateOutput(
      `${resourceName}_connection_string`,
      `azurerm_storage_account.${resourceName}.primary_connection_string`,
      `Connection string for the ${storage.name} storage account`,
      true
    ));
  });

  // Add common variables
  variables.push(generateVariable('storage_prefix', 'Prefix for storage account names', 'string', 'optimisely'));
  variables.push(generateVariable('storage_replication_type', 'Storage replication type', 'string', 'LRS'));
  variables.push(generateVariable('allowed_ips', 'List of allowed IP addresses for storage access', 'list(string)', []));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateNetworkResources(networks: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Generate Virtual Network resources
  const vnets = networks.filter(n => n.resourceType === 'VirtualNetwork' || n.name?.toLowerCase().includes('vnet'));

  vnets.forEach((vnet, index) => {
    const resourceName = sanitizeResourceName(vnet.name || `vnet_${index}`);
    const tags = generateAzureResourceTags(vnet);

    const resource = `# Virtual Network: ${vnet.name}
resource "azurerm_virtual_network" "${resourceName}" {
  name                = "\${var.vnet_prefix}-${resourceName}"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  address_space       = [var.${resourceName}_address_space]${tags}
}

# Default subnet
resource "azurerm_subnet" "${resourceName}_default" {
  name                 = "default"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.${resourceName}.name
  address_prefixes     = [var.${resourceName}_subnet_prefix]
}`;

    resources.push(resource);

    // Add variables for this VNet
    variables.push(generateVariable(`${resourceName}_address_space`, `Address space for ${vnet.name} VNet`, 'string', '10.0.0.0/16'));
    variables.push(generateVariable(`${resourceName}_subnet_prefix`, `Subnet prefix for ${vnet.name} default subnet`, 'string', '10.0.1.0/24'));

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `azurerm_virtual_network.${resourceName}.id`,
      `ID of the ${vnet.name} virtual network`
    ));

    outputs.push(generateOutput(
      `${resourceName}_subnet_id`,
      `azurerm_subnet.${resourceName}_default.id`,
      `ID of the default subnet in ${vnet.name}`
    ));
  });

  // Add common variables
  variables.push(generateVariable('vnet_prefix', 'Prefix for virtual network names', 'string', 'optimisely'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateTerraformTfvars(scanResult: ScanResult): string {
  return `# Terraform Variables for Azure Infrastructure
# Generated by Optimisely Cloud SDK

# General Configuration
location         = "${scanResult.region || 'East US'}"
project_name     = "optimisely-recreated"
environment      = "production"

# Resource Group
resource_group_name = "optimisely-resources"

# Virtual Machine Configuration
vm_prefix          = "optimisely"
vm_size_override   = ""
admin_username     = "azureuser"
admin_password     = ""  # Set a secure password
ssh_public_key_path = "~/.ssh/id_rsa.pub"
allowed_ssh_cidr   = "0.0.0.0/0"  # Restrict this for security

# Storage Configuration
storage_prefix          = "optimisely"
storage_replication_type = "LRS"
allowed_ips            = []  # Add your IP addresses

# Network Configuration
vnet_prefix = "optimisely"
`;
}

function generateAzureResourceTags(resource: CloudResource): string {
  const tags: { [key: string]: string } = { ...resource.tags };

  tags['GeneratedBy'] = 'optimisely-cloud-sdk';
  tags['GeneratedAt'] = new Date().toISOString();
  tags['OriginalId'] = resource.id;

  const tagEntries = Object.entries(tags).map(([key, value]) =>
    `    ${key} = "${value}"`
  ).join('\n');

  return tagEntries ? `\n\n  tags = {\n${tagEntries}\n  }` : '';
}

function mapAWSInstanceTypeToAzureVMSize(instanceType?: string): string {
  if (!instanceType) return 'Standard_B1s';

  const mapping: { [key: string]: string } = {
    't2.micro': 'Standard_B1s',
    't2.small': 'Standard_B1ms',
    't2.medium': 'Standard_B2s',
    't2.large': 'Standard_B2ms',
    't3.micro': 'Standard_B1s',
    't3.small': 'Standard_B1ms',
    't3.medium': 'Standard_B2s',
    't3.large': 'Standard_B2ms',
    't3.xlarge': 'Standard_B4ms',
    'm5.large': 'Standard_D2s_v3',
    'm5.xlarge': 'Standard_D4s_v3',
    'm5.2xlarge': 'Standard_D8s_v3',
    'c5.large': 'Standard_F2s_v2',
    'c5.xlarge': 'Standard_F4s_v2',
    'c5.2xlarge': 'Standard_F8s_v2',
    'r5.large': 'Standard_E2s_v3',
    'r5.xlarge': 'Standard_E4s_v3',
    'r5.2xlarge': 'Standard_E8s_v3'
  };

  return mapping[instanceType.toLowerCase()] || 'Standard_B2s';
}