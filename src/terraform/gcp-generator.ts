/**
 * GCP Terraform Generator
 * Generates Google Cloud Platform Terraform configurations from scan results
 */

import { ScanResult, CloudResource } from '../types';
import { TerraformOptions, TerraformOutput, sanitizeResourceName, generateResourceTags, generateVariable, generateOutput } from './index';

export async function generateGCPTerraform(
  scanResult: ScanResult,
  options: TerraformOptions
): Promise<TerraformOutput> {

  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];
  const modules: { [key: string]: string } = {};

  // Generate provider configuration
  const providerTf = generateGCPProvider();

  // Generate resources by type
  if (scanResult.resources.compute.length > 0) {
    const computeConfig = generateComputeInstances(scanResult.resources.compute, options);
    resources.push(computeConfig.resources);
    variables.push(...computeConfig.variables);
    outputs.push(...computeConfig.outputs);
  }

  if (scanResult.resources.storage.length > 0) {
    const storageConfig = generateStorageBuckets(scanResult.resources.storage, options);
    resources.push(storageConfig.resources);
    variables.push(...storageConfig.variables);
    outputs.push(...storageConfig.outputs);
  }

  if (scanResult.resources.network.length > 0) {
    const networkConfig = generateNetworkResources(scanResult.resources.network, options);
    resources.push(networkConfig.resources);
    variables.push(...networkConfig.variables);
    outputs.push(...networkConfig.outputs);
  }

  // Generate main configuration
  const mainTf = generateMainConfiguration(resources, scanResult);

  // Generate variables file if requested
  const variablesTf = options.variables ? variables.join('\n') : undefined;

  // Generate outputs file if requested
  const outputsTf = options.outputs ? outputs.join('\n') : undefined;

  // Generate terraform.tfvars file
  const terraformTfvars = generateTerraformTfvars(scanResult);

  return {
    mainTf,
    providerTf,
    variablesTf,
    outputsTf,
    terraformTfvars,
    modules: options.modules ? modules : undefined
  };
}

function generateGCPProvider(): string {
  return `# Google Cloud Provider Configuration
terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone

  # Optional: Specify credentials file
  # credentials = file("path/to/service-account-key.json")
}

# Enable required APIs
resource "google_project_service" "compute" {
  project = var.project_id
  service = "compute.googleapis.com"

  disable_dependent_services = true
}

resource "google_project_service" "storage" {
  project = var.project_id
  service = "storage.googleapis.com"

  disable_dependent_services = true
}

resource "google_project_service" "iam" {
  project = var.project_id
  service = "iam.googleapis.com"

  disable_dependent_services = true
}
`;
}

function generateMainConfiguration(resources: string[], scanResult: ScanResult): string {
  const header = `# GCP Infrastructure Configuration Generated by Optimisely Cloud SDK
# Original scan performed on: ${scanResult.timestamp}
# Provider: ${scanResult.provider.toUpperCase()}
# Region: ${scanResult.region}
# Total Resources: ${scanResult.totalResources}

`;

  return header + resources.join('\n\n');
}

function generateComputeInstances(instances: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Add common variables
  variables.push(generateVariable('machine_type_override', 'Override machine type for all instances', 'string', ''));
  variables.push(generateVariable('ssh_public_keys', 'List of SSH public keys for instances', 'list(string)', []));
  variables.push(generateVariable('network_tags', 'Network tags for firewall rules', 'list(string)', ['web-server', 'ssh-server']));

  instances.forEach((instance, index) => {
    const resourceName = sanitizeResourceName(instance.name || `instance_${index}`);
    const tags = generateGCPResourceLabels(instance);

    // Map AWS instance types to GCP machine types
    const machineType = mapAWSInstanceTypeToGCPMachineType(instance.instanceType) || 'e2-micro';
    const zone = instance.availabilityZone || '${var.zone}';

    const resource = `# Compute Instance: ${instance.name}
resource "google_compute_instance" "${resourceName}" {
  name         = "\${var.instance_prefix}-${resourceName}"
  machine_type = var.machine_type_override != "" ? var.machine_type_override : "${machineType}"
  zone         = "${zone}"

  # Boot disk configuration
  boot_disk {
    initialize_params {
      image = data.google_compute_image.${resourceName}.self_link
      size  = ${instance.storage?.size || 20}
      type  = "pd-ssd"
    }
  }

  # Network interface
  network_interface {
    network    = google_compute_network.${resourceName}_vpc.name
    subnetwork = google_compute_subnetwork.${resourceName}_subnet.name

    # Enable external IP
    access_config {
      // Ephemeral public IP
    }
  }

  # Metadata
  metadata = {
    ssh-keys = join("\\n", [for key in var.ssh_public_keys : "ubuntu:\${key}"])
  }

  # Network tags for firewall rules
  tags = var.network_tags

  # Service account
  service_account {
    email  = google_service_account.${resourceName}.email
    scopes = ["cloud-platform"]
  }

  # Startup script
  metadata_startup_script = file("\${path.module}/startup-scripts/${resourceName}.sh")${tags}

  depends_on = [
    google_project_service.compute
  ]
}

# Data source for latest Ubuntu image
data "google_compute_image" "${resourceName}" {
  family  = "ubuntu-2004-lts"
  project = "ubuntu-os-cloud"
}

# VPC Network for ${instance.name}
resource "google_compute_network" "${resourceName}_vpc" {
  name                    = "\${var.network_prefix}-${resourceName}-vpc"
  auto_create_subnetworks = false
}

# Subnet for ${instance.name}
resource "google_compute_subnetwork" "${resourceName}_subnet" {
  name          = "\${var.network_prefix}-${resourceName}-subnet"
  ip_cidr_range = "10.${index + 1}.0.0/16"
  region        = var.region
  network       = google_compute_network.${resourceName}_vpc.id

  # Enable private Google access
  private_ip_google_access = true
}

# Service Account for ${instance.name}
resource "google_service_account" "${resourceName}" {
  account_id   = "\${var.service_account_prefix}-${resourceName}"
  display_name = "Service Account for ${instance.name}"
  description  = "Service account for Compute Engine instance ${instance.name}"
}

# IAM binding for service account
resource "google_project_iam_member" "${resourceName}_compute_viewer" {
  project = var.project_id
  role    = "roles/compute.viewer"
  member  = "serviceAccount:\${google_service_account.${resourceName}.email}"
}

# Firewall rule for SSH
resource "google_compute_firewall" "${resourceName}_ssh" {
  name    = "\${var.firewall_prefix}-${resourceName}-ssh"
  network = google_compute_network.${resourceName}_vpc.name

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = [var.allowed_ssh_cidr]
  target_tags   = ["ssh-server"]
}

# Firewall rule for HTTP
resource "google_compute_firewall" "${resourceName}_http" {
  name    = "\${var.firewall_prefix}-${resourceName}-http"
  network = google_compute_network.${resourceName}_vpc.name

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["web-server"]
}

# Firewall rule for HTTPS
resource "google_compute_firewall" "${resourceName}_https" {
  name    = "\${var.firewall_prefix}-${resourceName}-https"
  network = google_compute_network.${resourceName}_vpc.name

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["web-server"]
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `google_compute_instance.${resourceName}.id`,
      `ID of the ${instance.name} compute instance`
    ));

    outputs.push(generateOutput(
      `${resourceName}_external_ip`,
      `google_compute_instance.${resourceName}.network_interface[0].access_config[0].nat_ip`,
      `External IP address of the ${instance.name} compute instance`
    ));

    outputs.push(generateOutput(
      `${resourceName}_internal_ip`,
      `google_compute_instance.${resourceName}.network_interface[0].network_ip`,
      `Internal IP address of the ${instance.name} compute instance`
    ));

    outputs.push(generateOutput(
      `${resourceName}_service_account_email`,
      `google_service_account.${resourceName}.email`,
      `Service account email for the ${instance.name} compute instance`
    ));
  });

  // Add common variables
  variables.push(generateVariable('instance_prefix', 'Prefix for instance names', 'string', 'optimisely'));
  variables.push(generateVariable('network_prefix', 'Prefix for network resource names', 'string', 'optimisely'));
  variables.push(generateVariable('service_account_prefix', 'Prefix for service account names', 'string', 'optimisely'));
  variables.push(generateVariable('firewall_prefix', 'Prefix for firewall rule names', 'string', 'optimisely'));
  variables.push(generateVariable('allowed_ssh_cidr', 'CIDR block allowed for SSH access', 'string', '0.0.0.0/0'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateStorageBuckets(buckets: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  buckets.forEach((bucket, index) => {
    const resourceName = sanitizeResourceName(bucket.name || `bucket_${index}`);
    const tags = generateGCPResourceLabels(bucket);

    const resource = `# Storage Bucket: ${bucket.name}
resource "google_storage_bucket" "${resourceName}" {
  name          = "\${var.bucket_prefix}-${bucket.name}-\${random_string.${resourceName}.result}"
  location      = var.bucket_location
  force_destroy = var.force_destroy_buckets

  # Versioning configuration
  versioning {
    enabled = var.enable_versioning
  }

  # Encryption configuration
  encryption {
    default_kms_key_name = var.kms_key_name
  }

  # Lifecycle management
  lifecycle_rule {
    condition {
      age = var.object_lifecycle_days
    }
    action {
      type = "Delete"
    }
  }

  lifecycle_rule {
    condition {
      age = var.nearline_lifecycle_days
    }
    action {
      type          = "SetStorageClass"
      storage_class = "NEARLINE"
    }
  }

  # Uniform bucket-level access
  uniform_bucket_level_access = var.uniform_bucket_level_access

  # CORS configuration (if needed for web applications)
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }${tags}

  depends_on = [
    google_project_service.storage
  ]
}

resource "random_string" "${resourceName}" {
  length  = 8
  special = false
  upper   = false
}

# IAM binding for bucket access (optional)
resource "google_storage_bucket_iam_member" "${resourceName}_admin" {
  bucket = google_storage_bucket.${resourceName}.name
  role   = "roles/storage.admin"
  member = "serviceAccount:\${var.storage_admin_email}"

  condition {
    title       = "Temporary access"
    description = "Expires after 90 days"
    expression  = "request.time < timestamp('\${timeadd(timestamp(), "90d")}')"
  }
}`;

    resources.push(resource);

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_name`,
      `google_storage_bucket.${resourceName}.name`,
      `Name of the ${bucket.name} storage bucket`
    ));

    outputs.push(generateOutput(
      `${resourceName}_url`,
      `google_storage_bucket.${resourceName}.url`,
      `URL of the ${bucket.name} storage bucket`
    ));

    outputs.push(generateOutput(
      `${resourceName}_self_link`,
      `google_storage_bucket.${resourceName}.self_link`,
      `Self link of the ${bucket.name} storage bucket`
    ));
  });

  // Add common variables
  variables.push(generateVariable('bucket_prefix', 'Prefix for bucket names', 'string', 'optimisely'));
  variables.push(generateVariable('bucket_location', 'Location for storage buckets', 'string', 'US'));
  variables.push(generateVariable('enable_versioning', 'Enable bucket versioning', 'bool', true));
  variables.push(generateVariable('force_destroy_buckets', 'Allow force destruction of buckets', 'bool', false));
  variables.push(generateVariable('kms_key_name', 'KMS key for bucket encryption', 'string', ''));
  variables.push(generateVariable('object_lifecycle_days', 'Days after which objects are deleted', 'number', 365));
  variables.push(generateVariable('nearline_lifecycle_days', 'Days after which objects move to Nearline', 'number', 30));
  variables.push(generateVariable('uniform_bucket_level_access', 'Enable uniform bucket-level access', 'bool', true));
  variables.push(generateVariable('storage_admin_email', 'Email of storage admin service account', 'string', ''));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateNetworkResources(networks: CloudResource[], options: TerraformOptions) {
  const resources: string[] = [];
  const variables: string[] = [];
  const outputs: string[] = [];

  // Generate VPC resources
  const vpcs = networks.filter(n => n.resourceType === 'VPC' || n.name?.toLowerCase().includes('vpc'));

  vpcs.forEach((vpc, index) => {
    const resourceName = sanitizeResourceName(vpc.name || `vpc_${index}`);
    const tags = generateGCPResourceLabels(vpc);

    const resource = `# VPC Network: ${vpc.name}
resource "google_compute_network" "${resourceName}" {
  name                    = "\${var.vpc_prefix}-${resourceName}"
  auto_create_subnetworks = false
  mtu                     = 1460${tags}
}

# Subnet in ${vpc.name}
resource "google_compute_subnetwork" "${resourceName}_subnet" {
  name          = "\${var.vpc_prefix}-${resourceName}-subnet"
  ip_cidr_range = var.${resourceName}_subnet_cidr
  region        = var.region
  network       = google_compute_network.${resourceName}.id

  # Enable private Google access
  private_ip_google_access = true

  # Secondary IP ranges (for GKE or other services)
  secondary_ip_range {
    range_name    = "pods"
    ip_cidr_range = var.${resourceName}_pods_cidr
  }

  secondary_ip_range {
    range_name    = "services"
    ip_cidr_range = var.${resourceName}_services_cidr
  }

  # Log configuration
  log_config {
    aggregation_interval = "INTERVAL_10_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

# Cloud Router for NAT
resource "google_compute_router" "${resourceName}_router" {
  name    = "\${var.vpc_prefix}-${resourceName}-router"
  region  = var.region
  network = google_compute_network.${resourceName}.id

  bgp {
    asn = 64514
  }
}

# Cloud NAT for private instances
resource "google_compute_router_nat" "${resourceName}_nat" {
  name                               = "\${var.vpc_prefix}-${resourceName}-nat"
  router                             = google_compute_router.${resourceName}_router.name
  region                             = google_compute_router.${resourceName}_router.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

# Default firewall rule for internal communication
resource "google_compute_firewall" "${resourceName}_internal" {
  name    = "\${var.vpc_prefix}-${resourceName}-allow-internal"
  network = google_compute_network.${resourceName}.name

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = [var.${resourceName}_subnet_cidr]
}`;

    resources.push(resource);

    // Add VPC-specific variables
    variables.push(generateVariable(`${resourceName}_subnet_cidr`, `CIDR range for ${vpc.name} subnet`, 'string', '10.0.0.0/24'));
    variables.push(generateVariable(`${resourceName}_pods_cidr`, `CIDR range for ${vpc.name} pods`, 'string', '10.1.0.0/16'));
    variables.push(generateVariable(`${resourceName}_services_cidr`, `CIDR range for ${vpc.name} services`, 'string', '10.2.0.0/16'));

    // Add outputs
    outputs.push(generateOutput(
      `${resourceName}_id`,
      `google_compute_network.${resourceName}.id`,
      `ID of the ${vpc.name} VPC network`
    ));

    outputs.push(generateOutput(
      `${resourceName}_self_link`,
      `google_compute_network.${resourceName}.self_link`,
      `Self link of the ${vpc.name} VPC network`
    ));

    outputs.push(generateOutput(
      `${resourceName}_subnet_id`,
      `google_compute_subnetwork.${resourceName}_subnet.id`,
      `ID of the ${vpc.name} subnet`
    ));
  });

  // Add common variables
  variables.push(generateVariable('vpc_prefix', 'Prefix for VPC resource names', 'string', 'optimisely'));

  return {
    resources: resources.join('\n\n'),
    variables,
    outputs
  };
}

function generateTerraformTfvars(scanResult: ScanResult): string {
  return `# Terraform Variables for GCP Infrastructure
# Generated by Optimisely Cloud SDK

# General Configuration
project_id   = ""  # Set your GCP project ID
region       = "${scanResult.region || 'us-central1'}"
zone         = "${scanResult.region || 'us-central1'}-a"

# Compute Configuration
instance_prefix         = "optimisely"
machine_type_override   = ""
ssh_public_keys        = []  # Add your SSH public keys
network_tags           = ["web-server", "ssh-server"]

# Network Configuration
network_prefix     = "optimisely"
service_account_prefix = "optimisely"
firewall_prefix    = "optimisely"
allowed_ssh_cidr   = "0.0.0.0/0"  # Restrict this for security

# Storage Configuration
bucket_prefix              = "optimisely"
bucket_location            = "US"
enable_versioning          = true
force_destroy_buckets      = false
kms_key_name              = ""
object_lifecycle_days      = 365
nearline_lifecycle_days    = 30
uniform_bucket_level_access = true
storage_admin_email        = ""  # Set your service account email

# VPC Configuration
vpc_prefix = "optimisely"
`;
}

function generateGCPResourceLabels(resource: CloudResource): string {
  const labels: { [key: string]: string } = {};

  // Convert tags to labels (GCP format)
  if (resource.tags) {
    Object.entries(resource.tags).forEach(([key, value]) => {
      // Convert to lowercase and replace invalid characters
      const labelKey = key.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
      const labelValue = value.toLowerCase().replace(/[^a-z0-9_-]/g, '_');
      labels[labelKey] = labelValue;
    });
  }

  // Add Optimisely labels
  labels['generated_by'] = 'optimisely_cloud_sdk';
  labels['generated_at'] = new Date().toISOString().replace(/[^a-z0-9_-]/g, '_');
  labels['original_id'] = resource.id.replace(/[^a-z0-9_-]/g, '_');

  const labelEntries = Object.entries(labels).map(([key, value]) =>
    `    ${key} = "${value}"`
  ).join('\n');

  return labelEntries ? `\n\n  labels = {\n${labelEntries}\n  }` : '';
}

function mapAWSInstanceTypeToGCPMachineType(instanceType?: string): string {
  if (!instanceType) return 'e2-micro';

  const mapping: { [key: string]: string } = {
    't2.nano': 'f1-micro',
    't2.micro': 'e2-micro',
    't2.small': 'e2-small',
    't2.medium': 'e2-medium',
    't2.large': 'e2-standard-2',
    't2.xlarge': 'e2-standard-4',
    't3.nano': 'f1-micro',
    't3.micro': 'e2-micro',
    't3.small': 'e2-small',
    't3.medium': 'e2-medium',
    't3.large': 'e2-standard-2',
    't3.xlarge': 'e2-standard-4',
    't3.2xlarge': 'e2-standard-8',
    'm5.large': 'n2-standard-2',
    'm5.xlarge': 'n2-standard-4',
    'm5.2xlarge': 'n2-standard-8',
    'm5.4xlarge': 'n2-standard-16',
    'c5.large': 'c2-standard-4',
    'c5.xlarge': 'c2-standard-8',
    'c5.2xlarge': 'c2-standard-16',
    'c5.4xlarge': 'c2-standard-30',
    'r5.large': 'n2-highmem-2',
    'r5.xlarge': 'n2-highmem-4',
    'r5.2xlarge': 'n2-highmem-8',
    'r5.4xlarge': 'n2-highmem-16'
  };

  return mapping[instanceType.toLowerCase()] || 'e2-small';
}